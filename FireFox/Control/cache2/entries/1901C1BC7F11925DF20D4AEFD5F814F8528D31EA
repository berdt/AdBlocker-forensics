/**
 * chkFrm : jQuery plugin which handles form validation
 *
 * @author	Boye Oomens <boye@e-sites.nl>
 * 			Joris van Summeren <joris@e-sites.nl>
 *
 * @since   10-02-2011
 * @version 3.2
 */
(function ($) {

	// Private vars
	var defaults = {
			errorContainer: 'div.error-container',
			errorClass: 'error',
			errorMessages: {},
			requiredClass: 'required',
			headMsg: 'Niet alle verplichte velden zijn correct ingevuld',
			defaultMsg: 'Het veld "%" is niet correct ingevuld',
			footMsg: 'Deze velden zijn geel gemarkeerd.',
			msgAttr: 'data-errorMsg', // name of the attribute for overridden error messages
			singleChecks: null, // id:event
			trackErrors: false,
			excludedValues: [],
			compare: {}, // e.g. for passwords
			scrollTo: false,
			// Callbacks
			onBeforeValidate: null,
			onFail: null,
			onSuccess: null
		},

		undef = undefined,

		// Default error messages
		errorMessages = {},

		// Regex validation patterns
		patterns = {
			'email': '^[_a-z0-9&+-]+(\\.[_a-z0-9&+-]+)*@[a-z0-9-]+(\\.[a-z0-9-]+)*(\\.[a-z]{2,6})$',
			'postal': '^([0-9]{4})([A-Z]{2})$',
			'date': '^([1-9]|0[1-9]|[12][0-9]|3[01])[- /.]([1-9]|0[1-9]|1[012])[- /.](19[0-9]{2}|20[0-9]{2})$',
			'numeric': '^[0-9]+$',
			'tel': '^([a-z0-9 +()-/:,]{9,})$',
			'url': '^(https?:\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?$',
			'specific': '' // Reserved to match specific fields
		};

	/**
	 * Native Array unique function because array_unique in jQuery 1.4 relies on browser specific methods
	 *
	 * @param a - Array
	 * @return array with unique elements
	 * @author Joris van Summeren <joris@e-sites.nl>
	 * @since 22 jan 2010
	 */
	function array_unique(a) {
		var r = [];

		o: for (var i = 0, n = a.length; i < n; i++) {
			for (var x = 0, y = r.length; x < y; x++) {
				if (r[x] === a[i]) {
					continue o;
				}
			}
			r[r.length] = a[i];
		}

		return r;
	}

	/**
	 * General validation constructor
	 *
	 * @author Boye Oomens <boye@e-sites.nl>
	 * @param {Object} form - form element
	 * @param {Object} event - jQuery event object
	 *
	 * @constructor
	 * @private
	 */
	function Chkfrm(form, o) {

		var self = this,
			frm = form,
			globalErrors = [],
			singleChecks = [],
			inputs = frm.find(':input').not(':submit,:radio,:checkbox,:disabled');

		// Extend context with API methods
		// These will be available in all callbacks as well as the data instance
		$.extend(self, {

			errors: [],

			/**
			 * Main validation method - the backbone of this plugin
			 *
			 * @author Boye Oomens <boye@e-sites.nl>
			 * @param {Object} event - jQuery event object
			 * @param {Object} el - element (optional)
			 * @return {Boolean}
			 */
			validate: function (event, el) {

				// Reset errors first
				self.errors = [];

				// Invoke onBeforeValidate callback
				if ( o.onBeforeValidate !== null && $.isFunction(o.onBeforeValidate) ) {
					o.onBeforeValidate.apply(self, arguments);
				}

				// Private vars	/ caching
				var req = el || frm.find('[required], [required="required"], .' + o.requiredClass),
					index = req.length,
					singleCheck = false,
					elem, $elem, elemKey, lblFor, $elemLbl,
					elemAndLbl, groups, groupedEls, elemClass;

				// Check for single elements to be checked
				if ( el ) {
					singleChecks = el;
					singleCheck = true;
				}

				// Manipulate the required resultset
				if ( event.type === 'submit' && singleChecks.length > 0 ) {
					req = array_unique( $.merge(singleChecks, req) );
					index = req.length;
				}

				// Start iteration over each required element checking their values based on element type
				while (index--) {
					elem = req[index],
					$elem = $(elem),
					elemKey = elem.name,
					elemVal = elem.value,
					elemClass = elem.className,
					lblFor = elem.id,
					$elemLbl = frm.find('label[for="' + lblFor + '"]'),
					elemAndLbl = $.merge($elem, $elemLbl),
					groups = null,	groupedElems = [];

					// Handle the error messages in the correct order
					if ( $elem.attr(o.msgAttr) !== undef ) {
						errorMessages[elemKey] = $elem.attr(o.msgAttr);
					} else {
						if ( !errorMessages.hasOwnProperty(elemKey) ) {
							errorMessages[elemKey] = o.defaultMsg.replace('%', elemKey);
						}
					}

					// Validate radio buttons and checkboxes
					if ( /(radio|checkbox)/.test(elem.type) ) {

						groups = frm.find('input[name="' + elemKey + '"]');

						if ( frm[0].id === 'intake' ) {
							groups = frm.find('input[name="' + elemKey + '"]');
						}

						// Store all elements that are checked
						for (var g = 0, gl = groups.length; g < gl; g++) {
							if ( groups[g].checked ) {
								groupedElems.push(groups[g]);
							}
						}

						// If the array is empty we know they aren't checked
						if ( !groupedElems.length ) {
							self.addError(elemKey);
							groups.next('label').addClass(o.errorClass);
						} else {
							// Remove error styles
							self.removeError(elemKey);
							self.reset(groups.next('label'));
						}

					}
					// Validate input, textarea and select elements
					else if ( $.trim(elemVal) === '' || self.isExcludedValue(elemVal) ) {
						self.errors.unshift(elemKey);
						elemAndLbl.addClass(o.errorClass);
					} else {
						// Take care of specific fields, such as email etc.
						if ( self.isSpecificField(elemClass) ) {

							// Strip the additional space in zipcodes
							if ( /(postal|zipcode|postcode)/.test(elemClass) ) {
								elemVal = elemVal.replace(/\s+/g, '');
							}

							if ( !self.isValidInput(self.getSpecificField(elemClass), elemVal) ) {
								self.removeError(elemKey);
								elemAndLbl.addClass(o.errorClass);
							} else {
								self.reset($elem);
								if ( singleCheck ) {
									elemAndLbl.addClass('no-error');
								}
							}

							self.compareValues();

						// Reset error styles
						} else {
							self.reset($elem);
							if ( singleCheck ) {
								elemAndLbl.addClass('no-error');
							}
						}

					}

				}

				// Print errors if there are any
				if ( event.type === 'submit' ) {
					if ( self.errors.length ) {
						self.handleErrors(event);
					} else {
						// Hide container
						$(o.errorContainer).fadeOut('medium');
						// Invoke onSuccess callback
						if ( o.onSuccess !== null && $.isFunction(o.onSuccess) ) {
							o.onSuccess.apply(self, arguments);
						}
						return true;
					}
				}

			},

			/**
			 * Gathers all errors in one string
			 *
			 * @author Boye Oomens <boye@e-sites.nl>
			 * @param none
			 * @return {String} string with all error messages
			 */
			printErrors: function (errors) {

				var err = self.errors,
					html = o.headMsg + '%messages%' + (o.footMsg ? '<br>' + o.footMsg : ''),
					messages = [];
					// Check for custom (multilingual) error messages and override the errorMessages object
					errorMessages = (typeof o.errorMessages === 'string' ? $.parseJSON(o.errorMessages) : $.extend(errorMessages, o.errorMessages));

				// Put all attached error messages in an array
				for (var a = 0, j = err.length; a < j; a++) {
					if ( errorMessages.hasOwnProperty(err[a]) ) {
						// Append messages
						messages.push('<li>' + errorMessages[err[a]] + '</li>');
						// Track errors through GA
						if ( o.trackErrors ) {
							self.trackError(frm[0].id, messages[msg]);
						}
					}
				}

				return html.replace(/%messages%/, (o.errorMessages !== false ? '<ul>' + array_unique(messages).join('') + '</ul>' : ''));

			},

			/**
			 * Function that handles all errors
			 *
			 * @author Boye Oomens <boye@e-sites.nl>
			 * @param {Array} err - array with errors
			 * @param {Object} e - jQuery event object
			 * @return none
			 */
			handleErrors: function (e) {

				// Show / append error container
				if ( o.errorContainer ) {
					if ( o.scrollTo ) {
						frm.scrollTo(500);
					}
					frm.find(o.errorContainer).html( self.printErrors() ).fadeIn('medium');
				}

				// Invoke onFail callback
				if ( o.onFail !== null && $.isFunction(o.onFail) ) {
					o.onFail.apply(self, arguments);
				}

				// Prevent default semantics
				e.preventDefault();

			},

			/**
			 * Checks if label elements contain an asterisk, if so the related input will get the required classname
			 * Please note that elements with the html5 required attribute are excluded
			 *
			 * @author Boye Oomens <boye@e-sites.nl>
			 * @param {Object} form - HTMLFormElement
			 * @return void
			 */
			setRequiredFields: function (form) {

				var context = form || 'body',
					labels = $('label:visible, .blockLbl', context),
					i = labels.length;

				while (i--) {
					if ( labels[i].innerHTML.indexOf('*') !== -1 ) {
						if ( $(':input', labels[i]).length ) {
							$('input, select, textarea', labels[i]).not(':disabled').addClass(o.requiredClass);
						} else {
							$('#'+labels[i].getAttribute('for'))
								.not('[required], [required=required]')
								.addClass(o.requiredClass);
						}

					}
				}
			},

			/**
			 * Compare values based on the given object
			 *
			 * @author Boye Oomens <boye@e-sites.nl>
			 * @param  {Object} obj - object
			 * @return {Array} err
			 */
			compareValues: function (obj) {

				if ( $.isEmptyObject(o.compare) ) {
					return [];
				}

				var err = [],
					compare = obj || o.compare,
					key, a, b;

				for (key in compare) {
					a = $('input[name=' + key + ']', frm)[0];
					b = $('input[name=' + o.compare[key] + ']', frm)[0];

					// Void elements or empty strings shouldn't be compared
					if ( (!a || !b) || (a && a.value === '') && (b && b.value === '') ) {
						return err;
					}

					// Compare actual values
					if ( a.value !== b.value ) {
						self.addError( b.name );
						$(b).add(frm.find('label[for=' + b.id + ']')).removeClass('noError').addClass(o.errorClass);
					}
				}

				return err;

			},

			/**
			 * Tracks errors by calling the push method from the global _gaq object.
			 *
			 * @author Joris van Summeren <joris@e-sites.nl>
			 * @param {String} action
			 * @param {String} label
			 * @return void
			 * @since 2 sep 2010
			 */
			trackError: function (action, label) {
				var category = 'Validation errors';

				if (typeof _gaq === 'object') {
					_gaq.push(['_trackEvent', category, action, label]);
				} else if (typeof pageTracker === 'object') {
					pageTracker._trackEvent(category, action, label);
				}
			},

			/**
			 * Simply returns the config object
			 *
			 * @author Boye Oomens <boye@e-sites.nl>
			 * @param void
			 * @return {Object} o
			 */
			getOptions: function () {
				return o;
			},

			/**
			 * Returns form context
			 *
			 * @author Boye Oomens <boye@e-sites.nl>
			 * @param none
			 * @return {Object}
			 */
			getForm: function () {
				return form;
			},

			/**
			 * Returns serialized form data
			 *
			 * @author Boye Oomens <boye@e-sites.nl>
			 * @param none
			 * @return {String}
			 */
			getFormData: function () {
				return form.serialize();
			},

			/**
			 * Returns matched string from the given className based on the specific regex
			 *
			 * @author Boye Oomens <boye@e-sites.nl>
			 * @param {String} c - className
			 * @return {String}
			 */
			getSpecificField: function (c) {
				if ( patterns['specific'] !== '' ) {
					return c.match(patterns['specific'])[0];
				}
				return false;
			},

			/**
			 * Check if given element has the correct classname
			 *
			 * @author Boye Oomens <boye@e-sites.nl>
			 * @param {String} elem - element to be checked
			 * @return {Boolean}
			 */
			isRequired: function (elem) {
				return ( !!elem.attr('required') || elem.hasClass(o.requiredClass) );
			},

			/**
			 * Checks whether we are dealing with an excluded value
			 *
			 * @author Boye Oomens <boye@e-sites.nl>
			 * @param {String} val - input value
			 * @return {Boolean}
			 */
			isExcludedValue: function (val) {
				return (val && $.inArray($.trim(val), o.excludedValues) !== -1);
			},

			/**
			 * Function which checks a string against a regular expression (based on the given pattern type)
			 * and returns either true or false
			 *
			 * @author Boye Oomens <boye@e-sites.nl>
			 * @param {String} type (optional)
			 * @param {String} input
			 * @param {String} pattern
			 * @return {Boolean}
			 */
			isValidInput: function (type, input, pattern) {
				var regex = new RegExp(pattern || patterns[type], 'i');
				return ( $.trim(input) !== '' && regex.test(input) );
			},

			/**
			 * Checks if the given className is a specific field (such as email, zipcode, etc.)
			 *
			 * @author Boye Oomens <boye@e-sites.nl>
			 * @param {String} c
			 * @return {Boolean}
			 */
			isSpecificField: function (c) {
				var fields = [];
				for (field in patterns) {
					fields.push(field);
				}
				patterns['specific'] = '(' + fields.join('|') + ')';
				return self.isValidInput(null, c, patterns['specific']);
			},

			/**
			 * Adds new validation pattern to the main pattern object
			 *
			 * @author Boye Oomens <boye@e-sites.nl>
			 * @param {String} id
			 * @param {String} pattern
			 * @return {Object} self
			 */
			addPattern: function (id, pattern) {
				if ( !errorMessages.hasOwnProperty(id) ) {
					patterns[id] = pattern;
					frm.find('#' + id).addClass(id); // Add a class to make it a specific field
				}
				return self;
			},

			/**
			 * Adds new error message to the main errorMessage object
			 *
			 * @author Boye Oomens <boye@e-sites.nl>
			 * @param {String} name
			 * @param {String} msg
			 * @return {Object} self
			 */
			addErrorMessage: function (name, msg) {
				errorMessages[name] = msg;
				return self;
			},

			/**
			 * Adds new error to the custom error array
			 *
			 * @author Boye Oomens <boye@e-sites.nl>
			 * @param {String} key
			 * @return {Object} chkFrm
			 */
			addError: function (key) {
				if ( $.inArray(key, self.errors) === -1 ) {
					self.errors.unshift( key );
				}
				return self;
			},

			/**
			 * Removes error from the error array and the corresponding error message
			 *
			 * @author Boye Oomens <boye@e-sites.nl>
			 * @param {String} key
			 * @return {Object} chkFrm
			 */
			removeError: function (key) {
				if ( key && $.inArray(key, self.errors) !== -1 ) {
					self.errors.splice($.inArray(key, self.errors), 1);
				}
				return self;
			},

			/**
			 * Remove all error related classes
			 *
			 * @author Boye Oomens <boye@e-sites.nl>
			 * @param {Object} el - optional element
			 * @return {Object} self
			 */
			reset: function (el) {
				if (el) {
					el.removeClass(o.errorClass);
				} else {
					frm.find('.' + o.errorClass).not('p').removeClass(o.errorClass);
				}
				return self;
			},

			/**
			 * Unbind all events
			 *
			 * @author Boye Oomens <boye@e-sites.nl>
			 * @return {Object} self
			 */
			destroy: function () {
				frm.unbind('submit');
				inputs.unbind();
				return self.reset();
			}

		});

		// Disable default html5 form validation
		// http://www.w3.org/TR/html5/association-of-controls-and-forms.html#attr-fs-novalidate
		frm[0].setAttribute('novalidate', 'novalidate');

		// Disable browser's default validation mechanism
		if ( inputs[0] && inputs[0].validity ) {
			inputs.each(function ()  {
				this.oninvalid = function () {
					return false;
				};
			});
		}

		// Determine required fields
		self.setRequiredFields(frm);

		// Bind form validation handler
		frm.on('submit', self.validate);

		// Single input validation
		if ( o.singleChecks ) {
			if ( typeof o.singleChecks === 'object') {
				for (evt in o.singleChecks) {
					if ( o.singleChecks.hasOwnProperty(evt) && /(change|blur|keyup)/.test(evt) ) {
						$(o.singleChecks[evt], frm).bind(evt, function (e) {
							self.validate(e, $(this));
						});
					}
				}
			} else if ( /(change|blur|keyup)/.test(o.singleChecks) ) {
				inputs.bind(o.singleChecks, function (e) {
					self.validate(e, $(this));
				});
			}

		}

	}

	/**
	 * jQuery plugin setup
	 *
	 * @param {Object} options - custom options
	 * @return {Object}
	 */
	jQuery.fn.chkFrm = function (options) {

		// Only deal with forms
		if ( this[0] && this[0].nodeName !== 'FORM' ) {
			throw new Error('Wrong element given: chkFrm only validates forms.');
		}

		var $self = this,
			instance = $self.data('chkFrm');

		// Destroy existing instance
		if ( instance ) {
			instance.destroy();
			$self.removeData('chkFrm');
		}

		// Extend default options
		options = $.extend(true, {}, defaults, options);

		// Return context
		$self.each(function () {
			instance = new Chkfrm($(this), options);
			$(this).data('chkFrm', instance);
		});

		return $self;

	};

}(jQuery));k=ßö'      X]RX]R=XãjXÀÏ÷   >    :http://vkmag.com/assets/js/vendor/jquery/jquery.chkFrm-3.2.js request-method GET response-head HTTP/1.1 200 OK
Date: Fri, 20 Jan 2017 00:43:59 GMT
Last-Modified: Sat, 26 Sep 2015 18:23:55 GMT
Etag: "5606e2bb-40dc"
X-Whom: web-01
Content-Type: application/javascript
Content-Length: 16604
Age: 0
X-Cache: MISS
X-Cache-Hits: 0
Accept-Ranges: bytes
 uncompressed-len 0   @Ü